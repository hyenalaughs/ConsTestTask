1	SQL - БАЗОВЫЕ ЗНАНИЯ  


1.1	Вопрос на знание select … join  
Есть две таблицы:  
Т1 (ID int, Text1 …., text2 …. B и т.д.)  
И   
Т2 (ID int, Text1 …., text2 …. B и т.д.)  

Написать select
1.	Вывести все поля из обеих таблиц, вывести записи при условии, что ID обеих таблиц совпадают.
2.	Вывести все поля из обеих таблиц, вывести все записи из T1 и только имеющиеся в T2
3.	Вывести все записи из T1, при условии, что таких ID нет в T2


Ответ:  
1.   
```sql
SELECT
    t1.*,
    t2.*
FROM T1 AS t1
INNER JOIN T2 AS t2
    ON t1.ID = t2.ID;
```

2.  
```sql
SELECT
    t1.*,
    t2.*
FROM T1 AS t1
LEFT JOIN T2 AS t2
    ON t1.ID = t2.ID;
```

3.  
```sql
SELECT
    t1.*
FROM T1 AS t1
LEFT JOIN T2 AS t2
    ON t1.ID = t2.ID
WHERE t2.ID IS NULL;
```

1.2	Как вывести результат запроса в XML?  


Пусть есть таблица T со следующим видом и содержанием. Что вернет SQL запрос?  
Id	Code	Name	StatusId  
1	gargadgadfga	Запрос предложений 1	45  
2	bsftrggdfgadfgdfat	Запрос предложений 2	2  
3	gfadgdfsgdfsgs	Запрос предложений 3	45  
4	afgereaerffdgvdf	Запрос предложений 4	3  
5	dgadfterdsgsdgad	Запрос предложений 5	45  
6	argrgag	Запрос предложений 6	2  

Написать запрос, выводящий данные в XML  

Ответ:  
```sql
SELECT 
    Id,
    Code,
    Name,
    StatusId
FROM T
FOR XML AUTO;
```


1.3	Как выбрать данные из поля с XML?  
Написать запрос, выбирающий данные из XML из предыдущего вопроса  
Отфильтровать данные по StatusId != 3  

```sql
SELECT
    x.value('(Id/text())[1]', 'INT')       AS Id,
    x.value('(Code/text())[1]', 'NVARCHAR(100)') AS Code,
    x.value('(Name/text())[1]', 'NVARCHAR(100)') AS Name,
    x.value('(StatusId/text())[1]', 'INT') AS StatusId
FROM T_XML
CROSS APPLY XmlData.nodes('/rows/row') AS t(x)
WHERE x.value('(StatusId/text())[1]', 'INT') != 3;
```


1.4	Что такое hints

Ответ:  Хинт (hint) – это указание оптимизатору запросов, которое переопределяет его поведение по умолчанию на время выполнения SQL инструкции.  
Иными словами, с помощью хинта мы можем сказать оптимизатору запросов, как именно поступить в той или иной ситуации в процессе построения плана запроса.  
Например, мы можем сказать, какой конкретно индекс использовать, какой конкретно алгоритм физического соединения таблиц применить, или, допустим, на время выполнения запроса разрешить «грязное чтение».  


1.5 Какие виды блокировок существуют?  

Ответ:  
Разделяемые (Shared) блокировки:  
- Разрешают нескольким транзакциям одновременно читать одни и те же данные.
- Не допускают изменений данных другими транзакциями, пока разделяемая блокировка активна.
- Обычно используются для операций чтения (SELECT).

Исключающие (Exclusive) блокировки:
- Разрешают только одной транзакции доступ к данным.
- Блокируют любые другие транзакции, пытающиеся получить доступ к тем же данным (включая чтение и изменение).
- Обычно используются для операций записи (UPDATE, DELETE, INSERT).

  
Блокировки обновления (Update):
- Предварительная блокировка, используемая перед изменением данных.
- Позволяет транзакциям убедиться, что данные не будут изменены другими транзакциями до того, как они будут обновлены.
- Используются для предотвращения взаимоблокировок (deadlocks).

  
Намерения (Intent) блокировки:
- Обозначают намерение заблокировать ресурс на более низком уровне. 
- Устанавливаются перед тем, как транзакция устанавливает более строгую блокировку на более низком уровне. 
- Помогают избежать конфликтов при блокировке иерархических структур данных.


1.6	Что такое транзакция?  

Ответ: Транзакция - набор операций, который в случае неудачи на одном из этапов отменяется полностью и результат выполнений откатывается до внесения изменений этой транзакцией.  


1.7	Чем delete … от truncate … отличается?  

Ответ:  

DELETE:  
- Удаляет строки построчно.  
- Каждая удалённая строка логируется в журнал транзакций (логируется операция для каждой строки).  
- Может быть медленным для больших таблиц.

TRUNCATE:  
- Удаляет все строки сразу (сбрасывает страницы данных).
- Логируется только факт очистки страниц, а не удаление каждой строки.
- Работает значительно быстрее на больших таблицах.


2.1	НАПИШИТЕ ХРАНИМУЮ ПРОЦЕДУРУ  
Постановка задачи  
/*  
Есть база данных в банке. В базе данных есть таблица со счетами (назовем её для простоты T). В таблице T есть среди прочих поля:  
N - Номер счета  
S - сумма на счете  
Требуется:  
Написать хранимую процедуру на языке SQL, которая:   
1. Принимает в качестве аргументов параметры:  
	@N1 - номер первого счета  
	@N2 - номер второго счета  
	@S - сумма денежных средств  
2. Переводит сумму @S с первого на второй счет, при это проверяя, достаточно ли средств на первом счете  
3. Использует транзакцию при переводе с первого на второй счет (показать, как работают транзакции).

Ответ:  
```sql
CREATE OR ALTER PROCEDURE dbo.TransferFunds
      @N1 bigint         
    , @N2 bigint          
    , @S  decimal(19,4)   
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;  

    -- Базовые валидации входа
    IF @S <= 0
    BEGIN
        THROW 50001, 'Сумма перевода должна быть > 0.', 1;
    END;

    IF @N1 = @N2
    BEGIN
        THROW 50002, 'Нельзя переводить на тот же счёт.', 1;
    END;

    BEGIN TRY
        BEGIN TRAN;

        DECLARE 
            @BalSource decimal(19,4),
            @BalDest   decimal(19,4);

        IF @N1 < @N2
        BEGIN
            SELECT @BalSource = S 
            FROM dbo.T WITH (UPDLOCK, HOLDLOCK, ROWLOCK)
            WHERE N = @N1;

            SELECT @BalDest = S
            FROM dbo.T WITH (UPDLOCK, HOLDLOCK, ROWLOCK)
            WHERE N = @N2;
        END
        ELSE
        BEGIN
            SELECT @BalDest = S
            FROM dbo.T WITH (UPDLOCK, HOLDLOCK, ROWLOCK)
            WHERE N = @N2;

            SELECT @BalSource = S 
            FROM dbo.T WITH (UPDLOCK, HOLDLOCK, ROWLOCK)
            WHERE N = @N1;
        END

        IF @BalSource IS NULL
            THROW 50003, 'Исходный счёт не найден.', 1;

        IF @BalDest IS NULL
            THROW 50004, 'Счёт-получатель не найден.', 1;

        IF @BalSource < @S
            THROW 50005, 'Недостаточно средств на исходном счёте.', 1;

        UPDATE dbo.T
        SET S = S - @S
        WHERE N = @N1;

        UPDATE dbo.T
        SET S = S + @S
        WHERE N = @N2;

        COMMIT TRAN;
    END TRY
    BEGIN CATCH
        IF XACT_STATE() <> 0
            ROLLBACK TRAN;

        THROW;
    END CATCH
END;
GO
```

